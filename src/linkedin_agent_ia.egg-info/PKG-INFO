Metadata-Version: 2.4
Name: linkedin-agent-ia
Version: 0.1.0
Summary: Agent IA validé humainement pour automatiser LinkedIn.
Requires-Python: >=3.11
Description-Content-Type: text/markdown
Requires-Dist: flask>=3.0
Requires-Dist: typer>=0.12
Requires-Dist: pydantic>=2.7
Requires-Dist: pydantic-settings>=2.2
Requires-Dist: httpx>=0.27
Requires-Dist: pyyaml>=6.0
Requires-Dist: pandas>=2.2
Requires-Dist: openpyxl>=3.1
Requires-Dist: python-dotenv>=1.0
Provides-Extra: dev
Requires-Dist: pytest>=8.2; extra == "dev"
Requires-Dist: black>=24.4; extra == "dev"
Requires-Dist: ruff>=0.4; extra == "dev"
Requires-Dist: mypy>=1.10; extra == "dev"

﻿# LinkedIn Agent IA

Agent IA Python capable de se connecter à l’API LinkedIn (via OAuth access token) pour rechercher des profils selon des critères simples (poste, localisation, entreprise, école) et envoyer automatiquement des invitations. Chaque action est tracée dans un fichier Excel pour conserver l’historique.

## Fonctionnalités actuelles
- API Flask (`POST /invitations`) qui reçoit uniquement des critères (pas besoin d’indiquer les noms) et génère les invitations.
- Connexion LinkedIn via access token OAuth 2.0 : les identifiants ne sont jamais stockés dans le code, tout passe par `.env`.
- Service de filtrage qui combine les résultats LinkedIn Live et un fallback local (`data/inputs/candidates.sample.json`).
- Journalisation complète des invitations dans `data/outputs/invitations.xlsx` (timestamp, critères, statut LinkedIn).
- CLI Typer pour piloter le workflow sans API.
- Tests Pytest + lint/format automatiques (GitHub Actions `ci.yml`).

## Stack
- Python 3.11
- Flask (serveur) + Typer (CLI)
- httpx pour communiquer avec LinkedIn
- Pandas/OpenPyXL pour l’export Excel

## Prérequis
```bash
python -m venv .venv
source .venv/bin/activate  # ou .\.venv\Scripts\Activate.ps1
pip install -e .
cp .env.example .env
```

## Configuration LinkedIn
1. Crée une application sur le [LinkedIn Developer Portal](https://www.linkedin.com/developers/).
2. Autorise les scopes `r_liteprofile`, `r_member_social`, `w_member_social` (et `rw_organization_admin` si besoin).
3. Récupère un access token (OAuth 2.0). Place-le dans `.env` :
```
LINKEDIN_ACCESS_TOKEN=eyJhbGciOi...
LINKEDIN_CLIENT_ID=<app id>
LINKEDIN_CLIENT_SECRET=<app secret>
```
> Attention : ne mets jamais tes identifiants/mots de passe LinkedIn ici. L’API requiert obligatoirement un token OAuth. Le fichier `.env` reste ignoré par Git.

Tu peux aussi ajuster :
- `INVITATION_DATASET_PATH` : fallback local JSON.
- `EXCEL_STORAGE_PATH` : sortie Excel.
- `LINKEDIN_BASE_URL` : utile si LinkedIn change de version.

## Lancer en local
```bash
# API Flask
flask --app linkedin_agent.app run --debug

# Workflow via CLI
typer linkedin_agent.cli send-invitations \
  --company "Air France" \
  --location "Ile-de-France" \
  --message "Bonjour, ravi d'échanger sur nos métiers."
```

Requête type vers l’API :
```json
{
  "filters": {
    "company": "Air France",
    "title": "Ingénieur",
    "location": "Ile-de-France"
  },
  "message": "Bonjour, je souhaite vous ajouter à mon réseau."
}
```

La réponse indique le nombre total de profils ciblés, les filtres utilisés et le statut de chaque invitation (`sent`, `pending`, `missing_profile_urn`, etc.).

## CI/CD
`make ci` exécute lint (`ruff`), formatage (`black`) et tests (`pytest`). Le workflow `.github/workflows/ci.yml` réplique cette suite sur GitHub Actions.

## Roadmap
1. Peaufiner la gestion OAuth (renouvellement automatique des tokens, refresh, webhook).
2. Ajouter d’autres workflows (génération de posts, veille d’offres) en réutilisant la même structure.
3. Brancher un mécanisme de validation humaine (e-mails) avant d’envoyer effectivement les invitations.
